#!/usr/bin/env python

from __future__ import division
import re
from numpy import *
import optparse
import cvxopt 
import cvxopt.solvers

usage = "usage: %prog [-c] [-C <dir>] [args...]"
parser = optparse.OptionParser(usage)
parser.add_option('-b','--bet',type=float,default=0.,help='set a fixed bet level')
parser.add_option('--plot',action='store_true',help="plot Alice's equity for bets in [0,bet]")
parser.add_option('-n',type=int,default=10,help="number of samples to plot")
options,args = parser.parse_args()
if len(args): parser.error('zero arguments expected')

cards = '23456789TJQKA'
nonpairs = [cards[i]+cards[j] for i in xrange(len(cards)) for j in xrange(i)]
hands = [c+c for c in cards]+[h+'s' for h in nonpairs]+[h+'o' for h in nonpairs]
assert len(hands)==13+13*12
hand_id = dict((h,i) for (i,h) in enumerate(hands))

# Load win probabilities of each hand vs. each other hand
def parse_preflop_matchups():
    pattern = re.compile(r'^(\w+)\s+vs\.\s+(\w+)\s+:\s+([\d.]+)\s+vs\.\s+([\d.]+)\s+$')
    win = -ones((len(hands),)*2)
    for line in open('preflop-matchups.txt'):
        m = pattern.match(line)
        assert m
        h0 = hand_id[m.group(1)]
        h1 = hand_id[m.group(2)]
        w0 = float(m.group(3))
        w1 = float(m.group(4))
        assert abs(w0+w1-1)<1e-5
        win[h0,h1] = w0
        win[h1,h0] = 1-w0
    i = arange(len(hands))
    win[i,i] = .5
    assert all(0<=win) and all(win<=1)
    assert all(abs(win+win.T-1)<=1e-10)
    return win
win = parse_preflop_matchups()

# Build a map from pairs of cards (represented as 4*id+suit) to hand ids
def compute_cards_to_hand():
    suits = xrange(4)
    cards_to_hand = -ones((4*len(cards),)*2,dtype=int)
    for c0 in xrange(len(cards)):
        h = hand_id[cards[c0]*2]
        for s0 in suits:
            for s1 in suits:
                if s0!=s1:
                    cards_to_hand[4*c0+s0,4*c0+s1] = h
        for c1 in xrange(c0):
            h = cards[c0]+cards[c1]
            hs = hand_id[h+'s']
            ho = hand_id[h+'o']
            for s0 in suits:
                cs0 = 4*c0+s0
                for s1 in suits:
                    cs1 = 4*c1+s1
                    cards_to_hand[cs0,cs1] = cards_to_hand[cs1,cs0] = hs if s0==s1 else ho
    return cards_to_hand
cards_to_hand = compute_cards_to_hand()
assert sum(cards_to_hand<0)==52

def hand_probabilities():
    # Count how many times h occurs in cards_to_hand for each h
    def prob(x):
        prob = empty(len(hands))
        for h in xrange(len(hands)):
            prob[h] = sum(x==h)
        return prob/sum(prob)
    hand_prob = prob(cards_to_hand)

    i = xrange(len(cards_to_hand))
    hand_to_cards = dict((cards_to_hand[c,d],(c,d)) for c in i for d in i)

    # Compute conditional probabilities of each hand given each other hand
    cond_hand_prob = empty((len(hands),)*2)
    for h in xrange(len(hands)):
        cs = hand_to_cards[h]
        remaining = array([i for i in xrange(13*4) if i not in cs])
        cond_hand_prob[h] = prob(cards_to_hand[remaining.reshape(-1,1),remaining.reshape(1,-1)])
    return hand_prob,cond_hand_prob
hand_prob,cond_hand_prob = hand_probabilities()
hand_hand_prob = hand_prob.reshape(-1,1)*cond_hand_prob
assert allclose(sum(hand_hand_prob),1)
assert allclose(hand_hand_prob,hand_hand_prob.T)

# Check all interesting conditional probabilities
assert allclose(hand_prob[hand_id['AA']],1/13*3/51)
assert allclose(hand_prob[hand_id['AKs']],2/13/51)
assert allclose(hand_prob[hand_id['AKo']],2/13*3/51)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AA']],2/50*1/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KK']],4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AKs']],2*2/50/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AKo']],2*2/50*3/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KQs']],2*4/50/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KQo']],2*4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AKs']],2*3/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AKo']],2*3/50*2/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AQs']],2*3/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AQo']],2*3/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['QJs']],2*4/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['QJo']],2*4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['AKo']],2/50*3/49+2*2/50*2/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['AQo']],2*3/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['QJo']],2*4/50*3/49)

# Switch to deterministic outcomes
if 0:
    outcome = dot(win,hand_prob)
    win[...] = outcome.reshape(-1,1)>outcome.reshape(1,-1)
    i = arange(len(outcome))
    win[i,i] = .5
    assert all(0<=win) and all(win<=1)
    assert all(abs(win+win.T-1)<=1e-10)
    rank = sorted(i,key=lambda i:outcome[i])
    print 'hand rank = %s'%(' '.join(hands[i] for i in rank))

def check_payoff_slow(bet,alice,bob,n=10000):
    '''Warning: This routine is slightly inaccurate, since it ignores the varying probability of
    overlapping suits of hands'''
    count = 0
    payoff = 0
    for _ in xrange(n):
        cs = random.randint(len(cards_to_hand),size=4)
        if sum(cs.reshape(-1,1)==cs.reshape(1,-1))!=4:
            continue
        count += 1
        ha = cards_to_hand[cs[0],cs[1]]
        hb = cards_to_hand[cs[2],cs[3]]
        if alice[ha]:
            if bob[hb]:
                payoff += (1+bet)*(2*win[ha,hb]-1)
            else:
                payoff += 1
    return payoff/count

def check_payoff_medium(bet,alice,bob):
    payoff = 0
    for ha in xrange(len(hands)):
        for hb in xrange(len(hands)):
            prob = hand_hand_prob[ha,hb]
            if alice[ha]:
                if bob[hb]:
                    payoff += (1+bet)*(2*win[ha,hb]-1)*prob
                else:
                    payoff += prob
    return payoff

def if_(c,a,b):
    return c*a+(1-c)*b # Use multiplication in order to work for all probabilities in [0,1]

def check_payoff(bet,alice,bob):
    return sum(hand_hand_prob*alice.reshape(-1,1)*if_(bob.reshape(1,-1),(1+bet)*(2*win-1),1))

def alice_payoff(bet,bob):
    "Alice's expected return from calling with each possible hand"
    return sum(cond_hand_prob*((1-bob.reshape(1,-1)) + (1+bet)*bob.reshape(1,-1)*(2*win-1)), axis=1)

def bob_payoff(bet,alice):
    "Bob's expected return from calling with each possible hand"
    hand_hand_call_prob = alice.reshape(1,-1)*hand_hand_prob
    inv_cond_hand_prob = hand_hand_call_prob / hand_hand_call_prob.sum(axis=1).reshape(-1,1)
    return sum(inv_cond_hand_prob*((2+bet)*win-bet*win.T), axis=1)

def always_call():
    alice = ones(len(hands),dtype=int)
    bob = ones(len(hands),dtype=int)
    return alice,bob

def ahash(*args):
    return hash(''.join(a.tostring() for a in args))

def zero_sum_nash_equilibrium_side(payoff):
    '''Alice chooses the row and Bob chooses the column.
    Given Alice's payoff matrix, we compute Alice's optimal payoff and (mixed) strategy.
    See http://en.wikipedia.org/wiki/Zero_sum_game for details.'''
    assert payoff.ndim==2
    M = payoff.T
    M = M - M.min()
    M = M/max(M.max(),1e-10)+1
    assert all(M>0)
    # We want to minimize sum(u) s.t. Mu >= 1, u >= 0.  Let M be m by n.
    # Adding positive slack variables s0,s1, this is
    #     min 1_n . u s.t. Mu = 1_m + s0, u = s1
    #     min 1_n . u s.t. -Mu + s0 = -1_m, -u + s1 = 0_n
    #     min 1_n . u s.t. -vstack(M,eye(n)) u + s0 = stack(-1_m,0_n)
    # According to http://abel.ee.ucla.edu/cvxopt/userguide/coneprog.html#linear-programming, this means
    m,n = M.shape
    c = ones(n)
    G = -vstack([M,eye(n)])
    h = hstack([-ones(m),zeros(n)])
    sol = cvxopt.solvers.lp(cvxopt.matrix(c),cvxopt.matrix(G),cvxopt.matrix(h))
    u = asarray(sol['x']).ravel()
    u /= sum(u)
    return dot(payoff.T,u).min(),u

def zero_sum_nash_equilibrium(payoff):
    A,alice = zero_sum_nash_equilibrium_side(payoff)
    B,bob = zero_sum_nash_equilibrium_side(-payoff.T)
    assert allclose(A,-B)
    return A,alice,bob

# Converge to heads up Nash equilibrium from an initial strategy guess
def poker_nash_equilibrium(bet,(alice,bob)=always_call(),n=1000,verbose=1):
    bounds = [-inf,inf]
    # Iterate until we detect looping
    hashes = set()
    looping = False
    strategies = []
    while 1:
        done = 1
        if verbose:
            print 'equity range = %g %g'%(bounds[0],bounds[1])
        # Make at most one change to Alice's strategy
        payoff = alice_payoff(bet,bob)
        bounds[1] = min(bounds[1],dot(hand_prob,maximum(0,payoff))) # Bob can hold Alice to below this
        error = payoff*((payoff>0)*(1-alice) - (payoff<0)*alice)
        h = argmax(error)
        if error[h]:
            alice = alice.copy()
            alice[h] = 1-alice[h]
            if verbose:
                print 'Alice should%s call with %s'%(('' if alice[h] else "n't"),hands[h])
            done = 0
        # Make at most one change to Bob's strategy
        payoff = bob_payoff(bet,alice)
        error = payoff*((payoff>0)*(1-bob) - (payoff<0)*bob)
        bounds[0] = max(bounds[0],check_payoff(bet,alice,payoff>0)) # Alice can hold Bob to above this
        h = argmax(error)
        if error[h]:
            bob = bob.copy()
            bob[h] = 1-bob[h]
            if verbose:
                print 'Bob should%s call with %s'%(('' if bob[h] else "n't"),hands[h])
            done = 0
        # Are we done?
        if done:
            strategies = [(alice,bob)]
            break
        ah = ahash(alice,bob)
        if verbose:
            print 'hash = %s'%ah
        if ah in hashes:
            if looping:
                break
            else:
                hashes = set()
            looping = True
        if looping:
            strategies.append((alice,bob))
        hashes.add(ah)
    # Print strategies
    print '\nfinal equity range = %g %g'%(bounds[0],bounds[1])
    for k,name in enumerate(['Alice','Bob']):
        print '%s has %d %s:'%(name,len(strategies),'strategy' if len(strategies)==1 else 'strategies')
        for s in strategies:
            call = s[k]
            print '  %d hands: %s'%(sum(call),' '.join(hands[i] for i in nonzero(call)[0]))
    # Compute exact Nash equilibrium matrix
    payoff = inf*ones((len(strategies),)*2)
    for a in xrange(len(strategies)):
        for b in xrange(len(strategies)):
            payoff[a,b] = check_payoff(bet,strategies[a][0],strategies[b][1])
    nash,alice,bob = zero_sum_nash_equilibrium(payoff)
    alice = sum(a*s[0] for a,s in zip(alice,strategies))
    bob = sum(b*s[1] for b,s in zip(bob,strategies))
    # Verify that we've found the Nash equilibrium
    equity = check_payoff(bet,alice,bob)
    atol = 3e-4
    assert allclose(equity,nash,atol=atol)
    assert bounds[0]-1e10<=equity<=bounds[1]+1e10
    print 'first error = %g'%(check_payoff(bet,alice,bob_payoff(bet,alice)>0)-equity)
    assert allclose(equity,check_payoff(bet,alice,bob_payoff(bet,alice)>0),atol=atol)
    print 'second error = %g'%(check_payoff(bet,alice_payoff(bet,bob)>0,bob)-equity)
    assert allclose(equity,check_payoff(bet,alice_payoff(bet,bob)>0,bob),atol=atol)
    return equity,alice,bob

if not options.plot:
    bet = options.bet
    equity,alice,bob = poker_nash_equilibrium(bet)
    assert allclose(equity,check_payoff(bet,alice,bob))
    print "Alice's exact payoff = %g"%equity
    if 0:
        print "Alice's approximate payoff = %g"%check_payoff_slow(bet,alice,bob)
        print "Alice's exact payoff = %g"%check_payoff_medium(bet,alice,bob)
else:
    bet = arange(options.n)
    bet = options.bet/bet[-1]*bet
    print 'bets = %s'%bet
    s = list(always_call())
    def nash(b):
        e,alice,bob = poker_nash_equilibrium(b,s,verbose=1)
        s[:] = round_(alice),round_(bob)
        return e
    equity = array([nash(b) for b in bet])
    import pylab
    pylab.plot(bet,equity)
    pylab.xlabel('bet')
    pylab.ylabel("Alice's equity")
    pylab.title("Alice's equity as a function of fixed bet size")
    pylab.show()
