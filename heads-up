#!/usr/bin/env python

from __future__ import division
import re
import sys
import optparse
from numpy import *
from nash import *
from fractions import Fraction

usage = "usage: %prog [options...] [args...]"
parser = optparse.OptionParser(usage)
parser.add_option('-b','--bet',type=float,default=0.,help='set a fixed bet level')
parser.add_option('--plot',action='store_true',help="plot Alice's equity for bets in [0,bet]")
parser.add_option('--max',action='store_true',help="maximize Alice's equity as a function of bet in [0,bet]")
parser.add_option('-n',type=int,default=10,help="number of samples to plot")
options,args = parser.parse_args()
if len(args): parser.error('zero arguments expected')

cards = '23456789TJQKA'
nonpairs = [cards[i]+cards[j] for i in xrange(len(cards)) for j in xrange(i)]
hands = [c+c for c in cards]+[h+'s' for h in nonpairs]+[h+'o' for h in nonpairs]
assert len(hands)==13+13*12
hand_id = dict((h,i) for (i,h) in enumerate(hands))

def die(s):
    print>>sys.stderr, s
    sys.exit(1)

# Load exact win probabilities.  Important: win[a,b]+win[b,a]<1 due to ties, unlike the approximate version above
def parse_exact_matchups():
    matchup_pattern = re.compile(r'^(\w+)\s+vs\.\s+(\w+):$')
    entry_pattern = re.compile(r'^\s+(Alice|Bob|Tie):\s+(\d+/\d+) = ([\d.]+)$')
    lines = open('exact.txt').readlines()
    assert len(lines)%4==0
    win = zeros((len(hands),)*2,dtype=object)
    for i in xrange(len(lines)//4):
        m = matchup_pattern.match(lines[4*i])
        if not m: die('Weird matchup line: %s'%lines[4*i][:-1])
        h0,h1 = hand_id[m.group(1)],hand_id[m.group(2)]
        def entry(j,name):
            m = entry_pattern.match(lines[4*i+j+1])
            if not m: die('Weird entry line: %s'%lines[4*i+j+1][:-1])
            assert m.group(1)==name
            return Fraction(m.group(2))
        w,l,t= entry(0,'Alice'),entry(1,'Bob'),entry(2,'Tie')
        assert w+l+t==1
        win[h0,h1] = w
        win[h1,h0] = l
    assert all(win>0)
    return win
exact_win = parse_exact_matchups()
win = exact_win.astype(float)
win = win+(1-win-win.T)/2
assert allclose(win+win.T,1)

# Build a map from pairs of cards (represented as 4*id+suit) to hand ids
def compute_cards_to_hand():
    suits = xrange(4)
    cards_to_hand = -ones((4*len(cards),)*2,dtype=int)
    for c0 in xrange(len(cards)):
        h = hand_id[cards[c0]*2]
        for s0 in suits:
            for s1 in suits:
                if s0!=s1:
                    cards_to_hand[4*c0+s0,4*c0+s1] = h
        for c1 in xrange(c0):
            h = cards[c0]+cards[c1]
            hs = hand_id[h+'s']
            ho = hand_id[h+'o']
            for s0 in suits:
                cs0 = 4*c0+s0
                for s1 in suits:
                    cs1 = 4*c1+s1
                    cards_to_hand[cs0,cs1] = cards_to_hand[cs1,cs0] = hs if s0==s1 else ho
    return cards_to_hand
cards_to_hand = compute_cards_to_hand()
assert sum(cards_to_hand<0)==52

def hand_probabilities():
    # Count how many times h occurs in cards_to_hand for each h
    def prob(x):
        prob = empty(len(hands))
        for h in xrange(len(hands)):
            prob[h] = sum(x==h)
        return prob/sum(prob)
    hand_prob = prob(cards_to_hand)

    i = xrange(len(cards_to_hand))
    hand_to_cards = dict((cards_to_hand[c,d],(c,d)) for c in i for d in i)

    # Compute conditional probabilities of each hand given each other hand
    cond_hand_prob = empty((len(hands),)*2)
    for h in xrange(len(hands)):
        cs = hand_to_cards[h]
        remaining = array([i for i in xrange(13*4) if i not in cs])
        cond_hand_prob[h] = prob(cards_to_hand[remaining.reshape(-1,1),remaining.reshape(1,-1)])
    return hand_prob,cond_hand_prob
hand_prob,cond_hand_prob = hand_probabilities()
hand_hand_prob = hand_prob.reshape(-1,1)*cond_hand_prob
assert allclose(sum(hand_hand_prob),1)
assert allclose(hand_hand_prob,hand_hand_prob.T)

# Check all interesting conditional probabilities
assert allclose(hand_prob[hand_id['AA']],1/13*3/51)
assert allclose(hand_prob[hand_id['AKs']],2/13/51)
assert allclose(hand_prob[hand_id['AKo']],2/13*3/51)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AA']],2/50*1/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KK']],4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AKs']],2*2/50/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['AKo']],2*2/50*3/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KQs']],2*4/50/49)
assert allclose(cond_hand_prob[hand_id['AA'],hand_id['KQo']],2*4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AKs']],2*3/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AKo']],2*3/50*2/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AQs']],2*3/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['AQo']],2*3/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['QJs']],2*4/50/49)
assert allclose(cond_hand_prob[hand_id['AKs'],hand_id['QJo']],2*4/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['AKo']],2/50*3/49+2*2/50*2/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['AQo']],2*3/50*3/49)
assert allclose(cond_hand_prob[hand_id['AKo'],hand_id['QJo']],2*4/50*3/49)

# Switch to deterministic outcomes
if 0:
    outcome = dot(win,hand_prob)
    win[...] = outcome.reshape(-1,1)>outcome.reshape(1,-1)
    i = arange(len(outcome))
    win[i,i] = .5
    assert all(0<=win) and all(win<=1)
    assert all(abs(win+win.T-1)<=1e-10)
    rank = sorted(i,key=lambda i:outcome[i])
    print 'hand rank = %s'%(' '.join(hands[i] for i in rank))

def check_payoff_slow(bet,alice,bob):
    payoff = 0
    for ha in xrange(len(hands)):
        for hb in xrange(len(hands)):
            prob = hand_hand_prob[ha,hb]
            if alice[ha]:
                if bob[hb]:
                    payoff += (1+bet)*(2*win[ha,hb]-1)*prob
                else:
                    payoff += prob
    return payoff

def if_(c,a,b):
    return c*a+(1-c)*b # Use multiplication in order to work for all probabilities in [0,1]

def check_payoff(bet,alice,bob):
    return sum(hand_hand_prob*alice.reshape(-1,1)*if_(bob.reshape(1,-1),(1+bet)*(2*win-1),1))

def alice_payoff(bet,bob):
    "Alice's expected return from calling with each possible hand"
    return sum(cond_hand_prob*((1-bob.reshape(1,-1)) + (1+bet)*bob.reshape(1,-1)*(2*win-1)), axis=1)

def bob_payoff(bet,alice):
    "Bob's expected return from calling with each possible hand"
    hand_hand_call_prob = alice.reshape(1,-1)*hand_hand_prob
    inv_cond_hand_prob = hand_hand_call_prob / hand_hand_call_prob.sum(axis=1).reshape(-1,1)
    return sum(inv_cond_hand_prob*((2+bet)*win-bet*win.T), axis=1)

def always_call():
    alice = ones(len(hands),dtype=int)
    bob = ones(len(hands),dtype=int)
    return alice,bob

def ahash(*args):
    return hash(''.join(a.tostring() for a in args))

# Converge to heads up Nash equilibrium from an initial strategy guess
def poker_nash_equilibrium(bet,(alice,bob)=always_call(),n=1000,verbose=1):
    alice = alice.astype(bool)
    bob = bob.astype(bool)
    bounds = [-inf,inf]
    # Iterate until we detect looping
    hashes = set()
    looping = False
    strategies = []
    while 1:
        done = 1
        if verbose:
            print 'equity range = %g %g'%(bounds[0],bounds[1])
        # Make at most one change to Alice's strategy
        payoff = alice_payoff(bet,bob)
        bounds[1] = min(bounds[1],dot(hand_prob,maximum(0,payoff))) # Bob can hold Alice to below this
        error = payoff*((payoff>0)*(1-alice) - (payoff<0)*alice)
        h = argmax(error)
        if error[h]:
            alice = alice.copy()
            alice[h] = 1-alice[h]
            if verbose:
                print 'Alice should%s call with %s'%(('' if alice[h] else "n't"),hands[h])
            done = 0
        # Make at most one change to Bob's strategy
        payoff = bob_payoff(bet,alice)
        error = payoff*((payoff>0)*(1-bob) - (payoff<0)*bob)
        bounds[0] = max(bounds[0],check_payoff(bet,alice,payoff>0)) # Alice can hold Bob to above this
        h = argmax(error)
        if error[h]:
            bob = bob.copy()
            bob[h] = 1-bob[h]
            if verbose:
                print 'Bob should%s call with %s'%(('' if bob[h] else "n't"),hands[h])
            done = 0
        # Are we done?
        if done:
            strategies = [(alice,bob)]
            break
        ah = ahash(alice,bob)
        if verbose:
            print 'hash = %s'%ah
        if ah in hashes:
            if looping:
                break
            else:
                hashes = set()
            looping = True
        if looping:
            strategies.append((alice,bob))
        hashes.add(ah)
    # Print strategies
    print '\nfinal equity range = %g %g'%(bounds[0],bounds[1])
    for k,name in enumerate(['Alice','Bob']):
        print '%s has %d %s:'%(name,len(strategies),'strategy' if len(strategies)==1 else 'strategies')
        for s in strategies:
            call = s[k]
            print '  %d hands: %s'%(sum(call),' '.join(hands[i] for i in nonzero(call)[0]))
    # Compute exact Nash equilibrium matrix
    alices = [s[0] for s in strategies]
    bobs = [s[1] for s in strategies]
    while 1:
        # Compute Nash equilibrium ranging over our current list of Alice's and Bob's strategies
        payoff = empty((len(alices),len(bobs)))
        for a,alice in enumerate(alices):
            for b,bob in enumerate(bobs):
                payoff[a,b] = check_payoff(bet,alice,bob)
        nash,alice,bob = zero_sum_nash_equilibrium(payoff)
        alice = sum(a*s for a,s in zip(alice,alices))
        bob = sum(b*s for b,s in zip(bob,bobs))
        # Determine Alice's and Bob's new optimal strategies, and add them to our lists if necessary
        done = 1
        opt_alice = alice_payoff(bet,bob)>0
        if ahash(opt_alice) not in map(ahash,alices):
            alices.append(opt_alice)
            done = 0
        opt_bob = bob_payoff(bet,alice)>0
        if ahash(opt_bob) not in map(ahash,bobs):
            bobs.append(opt_bob)
            done = 0
        if done:
            break
    # Verify that we've found the Nash equilibrium
    equity = check_payoff(bet,alice,bob)
    assert allclose(equity,nash)
    assert bounds[0]-1e10<=equity<=bounds[1]+1e10
    print 'first error = %g'%(check_payoff(bet,alice,bob_payoff(bet,alice)>0)-equity)
    assert allclose(equity,check_payoff(bet,alice,bob_payoff(bet,alice)>0))
    print 'second error = %g'%(check_payoff(bet,alice_payoff(bet,bob)>0,bob)-equity)
    assert allclose(equity,check_payoff(bet,alice_payoff(bet,bob)>0,bob))
    # Print out nice results
    if verbose:
        def str_strategy(strat,payoff):
            order = sorted(arange(len(strat)),key=lambda i:-payoff[i])
            return ' '.join(('' if allclose(strat[i],1) else '%g*'%strat[i])+hands[i] for i in order if strat[i]>1e-5)
        print
        print 'Alice: %d hands, %s'%(sum(alice>1e-5),str_strategy(alice,alice_payoff(bet,bob)))
        print 'Bob: %d hands, %s'%(sum(bob>1e-5),str_strategy(bob,bob_payoff(bet,alice)))
    return equity,alice,bob

def poker_nash_equilibrium_remember(bet,last=list(always_call())):
    equity,alice,bob = poker_nash_equilibrium(bet,last)
    last[:] = round_(alice),round_(bob)
    return equity

if options.plot:
    bet = arange(options.n)
    bet = options.bet/bet[-1]*bet
    print 'bets = %s'%bet
    s = list(always_call())
    def nash(b):
        e,alice,bob = poker_nash_equilibrium(b,s,verbose=1)
        s[:] = round_(alice),round_(bob)
        return e
    equity = array(map(poker_nash_equilibrium_remember,bet))
    import pylab
    pylab.plot(bet,equity)
    pylab.xlabel('bet')
    pylab.ylabel("Alice's equity")
    pylab.title("Alice's equity as a function of fixed bet size")
    pylab.show()
elif options.max:
    import scipy.optimize
    bet,equity,_,evals = scipy.optimize.fminbound(lambda b:-poker_nash_equilibrium_remember(b),0,options.bet,full_output=1,xtol=1e-8)
    print "\nAlice's preferred bet = %g"%bet
    print "Alice's equity = %g"%-equity
    print "Nash equilibrium computations = %d"%evals
else:
    bet = options.bet
    equity,alice,bob = poker_nash_equilibrium(bet)
    assert allclose(equity,check_payoff(bet,alice,bob))
    print "Alice's exact payoff = %g"%equity
    if 0:
        print "Alice's exact payoff = %g"%check_payoff_slow(bet,alice,bob)

